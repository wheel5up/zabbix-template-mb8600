#!/usr/bin/env node
// mb8600.js
const https = require("https");
var args;

function parseArgs(argv) {
  const args = {
    username: null,
    password: null,
    verbose: false,
    getDownstream: false,
    getUpstream: false,
    getStatus: false,
    getSoftware: false,
    getConnection: false,
  };

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];
    switch (arg) {
      case "-u":
        if (!argv[i + 1]) {
          throw new Error("Missing value for -u (username)");
        }
        args.username = argv[++i];
        break;
      case "-p":
        if (!argv[i + 1]) {
          throw new Error("Missing value for -p (password)");
        }
        args.password = argv[++i];
        break;
      case "-h":
        if (!argv[i + 1]) {
          throw new Error("Missing value for -h (host)");
        }
        args.host = argv[++i];
        break;
      case "-v":
        args.verbose = true;
        break;
      case "-down":
        args.getDownstream = true;
        break;
      case "-up":
        args.getUpstream = true;
        break;
      case "-status":
        args.getStatus = true;
        break;
      case "-software":
        args.getSoftware = true;
        break;
      case "-connection":
        args.getConnection = true;
        break;
      default:
        throw new Error(`Unknown argument: ${arg}`);
    }
  }

  if (!args.username || !args.password) {
    throw new Error("Both -u (username) and -p (password) are required.");
  }

  return args;
}

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */

function hex_hmac_md5(k, d) {
  return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data) {
  var bkey = rstr2binl(key);
  if (bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16),
    opad = Array(16);
  for (var i = 0; i < 16; i++) {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5c5c5c5c;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input) {
  var hexcase = 0;
  try {
    hexcase;
  } catch (e) {
    hexcase = 0;
  }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for (var i = 0; i < input.length; i++) {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0f) + hex_tab.charAt(x & 0x0f);
  }
  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input) {
  var output = "";
  var i = -1;
  var x, y;

  while (++i < input.length) {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if (0xd800 <= x && x <= 0xdbff && 0xdc00 <= y && y <= 0xdfff) {
      x = 0x10000 + ((x & 0x03ff) << 10) + (y & 0x03ff);
      i++;
    }

    /* Encode output as utf-8 */
    if (x <= 0x7f) output += String.fromCharCode(x);
    else if (x <= 0x7ff)
      output += String.fromCharCode(
        0xc0 | ((x >>> 6) & 0x1f),
        0x80 | (x & 0x3f),
      );
    else if (x <= 0xffff)
      output += String.fromCharCode(
        0xe0 | ((x >>> 12) & 0x0f),
        0x80 | ((x >>> 6) & 0x3f),
        0x80 | (x & 0x3f),
      );
    else if (x <= 0x1fffff)
      output += String.fromCharCode(
        0xf0 | ((x >>> 18) & 0x07),
        0x80 | ((x >>> 12) & 0x3f),
        0x80 | ((x >>> 6) & 0x3f),
        0x80 | (x & 0x3f),
      );
  }
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input) {
  var output = Array(input.length >> 2);
  for (var i = 0; i < output.length; i++) output[i] = 0;
  for (var i = 0; i < input.length * 8; i += 8)
    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input) {
  var output = "";
  for (var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);

    a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t) {
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
}
function md5_ff(a, b, c, d, x, s, t) {
  return md5_cmn((b & c) | (~b & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t) {
  return md5_cmn((b & d) | (c & ~d), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t) {
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t) {
  return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xffff);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt));
}

function changText(str) {
  const ar = str.split("");
  for (let i = 0; i < ar.length; i++) {
    if (ar[i].charCodeAt(0) >= 65 && ar[i].charCodeAt(0) <= 90) {
      ar[i] = ar[i].toLowerCase();
    } else if (ar[i].charCodeAt(0) >= 97 && ar[i].charCodeAt(0) <= 122) {
      ar[i] = ar[i].toUpperCase();
    }
  }
  return ar.join("");
}

function parseDownstreamChannelInfo(rawString) {
  const rows = rawString.split("|+|");
  const result = rows.map((entry) => {
    const fields = entry.split("^").map((f) => f.trim());

    return {
      channel: parseInt(fields[0]),
      lockStatus: fields[1],
      modulation: fields[2],
      channelId: parseInt(fields[3]),
      frequencyMHz: parseFloat(fields[4]),
      powerdBmV: parseFloat(fields[5]),
      snrDb: parseFloat(fields[6]),
      corrected: parseInt(fields[7]),
      uncorrected: parseInt(fields[8]),
    };
  });

  return result;
}

function parseUpstreamChannelInfo(rawString) {
  const rows = rawString.split("|+|");
  const result = rows
    .filter((entry) => entry.trim() !== "")
    .map((entry) => {
      const fields = entry.split("^").map((f) => f.trim());

      return {
        channel: parseInt(fields[0]), // Channel Number
        lockStatus: fields[1], // Locked
        modulation: fields[2], // SC-QAM
        channelId: parseInt(fields[3]), // Channel ID
        symbolRateKsymSec: parseFloat(fields[4]), // Symbol Rate
        powerdBmV: parseFloat(fields[5]), // Power
        frequencyMHz: parseFloat(fields[6]), // Frequency
      };
    });

  return result;
}

function makeRequest(action, soapAction, headers, body, cookie = "") {
  return new Promise((resolve, reject) => {
    const payload = JSON.stringify(body);
    const options = {
      hostname: args.host,
      port: 443,
      path: "/HNAP1/",
      method: "POST",
      rejectUnauthorized: false,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        SOAPAction: `"${soapAction}"`,
        "Content-Length": Buffer.byteLength(payload),
        "User-Agent": "curl/8.5.0",
        Connection: "keep-alive",
        ...(cookie ? { Cookie: cookie } : {}),
        ...headers,
      },
    };

    if (args.verbose) {
      console.log(`\n➡️  [${action}] Sending request...`);
      console.log("🔸 Headers:", options.headers);
      console.log("🔸 Body:", payload);
    }

    const req = https.request(options, (res) => {
      let data = "";
      res.on("data", (chunk) => (data += chunk));
      res.on("end", () => {
        if (args.verbose) {
          console.log(`✅ Received response for [${action}]`);
          console.log("📥 Raw response:", data);
        }
        try {
          const parsed = JSON.parse(data);
          resolve(parsed);
        } catch (e) {
          reject(e);
        }
      });
    });

    req.on("error", reject);
    req.write(payload);
    req.end();
  });
}
async function fetchChannelInfo(type, privateKey, cookieHeader) {
  const timestamp = Date.now();
  const actionMap = {
    down: {
      soapKey: "GetMotoStatusDownstreamChannelInfo",
      responseKey: "GetMotoStatusDownstreamChannelInfoResponse",
      field: "MotoConnDownstreamChannel",
      parser: parseDownstreamChannelInfo,
    },
    up: {
      soapKey: "GetMotoStatusUpstreamChannelInfo",
      responseKey: "GetMotoStatusUpstreamChannelInfoResponse",
      field: "MotoConnUpstreamChannel",
      parser: parseUpstreamChannelInfo,
    },
    status: {
      soapKey: "GetMotoStatusConnectionInfo",
      responseKey: "GetMotoStatusConnectionInfoResponse",
      parser: (x) => x,
    },
    software: {
      soapKey: "GetMotoStatusSoftware",
      responseKey: "GetMotoStatusSoftwareResponse",
      parser: (x) => x,
    },
    connection: {
      soapKey: "GetHomeConnection",
      responseKey: "GetHomeConnectionResponse",
      parser: (x) => x,
    },
  };

  const meta = actionMap[type];
  if (!meta) {
    throw new Error(`Unsupported channel type: ${type}`);
  }

  const soapAction = '"http://purenetworks.com/HNAP1/GetMultipleHNAPs"';
  const hnapAuth = `${changText(
    hex_hmac_md5(privateKey, `${timestamp}${soapAction}`),
  )} ${timestamp}`;

  const body = {
    GetMultipleHNAPs: {
      [meta.soapKey]: "",
    },
  };

  const response = await makeRequest(
    meta.soapKey,
    soapAction.replace(/"/g, ""),
    { HNAP_AUTH: hnapAuth },
    body,
    cookieHeader,
  );

  const raw = meta.field
    ? response?.[meta.responseKey]?.[meta.field]
    : response?.[meta.responseKey];

  //  const raw = response?.[meta.responseKey]?.[meta.field];
  if (!raw) {
    throw new Error(`Missing expected response data for ${type}`);
  }

  return meta.parser(raw);
}

(async () => {
  try {
    const argv = process.argv.slice(2);
    args = parseArgs(argv);

    if (args.verbose)
      console.log("Parsed args:", JSON.stringify(args, null, 2));

    // Example usage:
    if (args.verbose) console.log("Verbose mode is enabled");
    if (args.getDownstream && args.verbose)
      console.log("Will fetch downstream channel info");
  } catch (err) {
    console.error("❌ Argument error:", err.message);
    process.exit(1);
  }

  const loginRequest = {
    Login: {
      Action: "request",
      Username: args.username,
      LoginPassword: args.password,
      Captcha: "",
      PrivateLogin: "LoginPassword",
    },
  };

  const challengeResp = await makeRequest(
    "Login",
    "http://purenetworks.com/HNAP1/Login",
    {},
    loginRequest,
    "Secure",
  );
  const loginResp = challengeResp?.LoginResponse;
  if (args.verbose) console.log("📥 Login challenge response:", loginResp);

  if (!loginResp || loginResp.LoginResult !== "OK") {
    console.error("❌ Login challenge failed or unexpected format.");
    return;
  }

  const Challenge = loginResp.Challenge;
  const PublicKey = loginResp.PublicKey;
  const Cookie = loginResp.Cookie;

  const PrivateKey = hex_hmac_md5(
    PublicKey + args.password,
    Challenge,
  ).toUpperCase();
  const LoginPassword = hex_hmac_md5(PrivateKey, Challenge).toUpperCase();

  const timestamp = Date.now();
  const authString = `"http://purenetworks.com/HNAP1/Login"${timestamp}`;
  const rawHmac = hex_hmac_md5(PrivateKey, authString);
  const HNAP_AUTH = `${changText(rawHmac)} ${timestamp}`;
  const cookieHeader = `uid=${Cookie}; PrivateKey=${PrivateKey};`;

  if (args.verbose) {
    console.log("🔐 Computed Values:");
    console.log("🔑 Challenge:", Challenge);
    console.log("🔑 PublicKey:", PublicKey);
    console.log("🔐 PrivateKey:", PrivateKey);
    console.log("🔐 LoginPassword:", LoginPassword);
    console.log("🍪 Cookie Header:", cookieHeader);
    console.log("🔐 HNAP_AUTH Header (login):", HNAP_AUTH);
  }

  const loginFinal = {
    Login: {
      Action: "login",
      Username: args.username,
      LoginPassword,
      Captcha: "",
      PrivateLogin: "LoginPassword",
    },
  };

  const finalResp = await makeRequest(
    "Login",
    "http://purenetworks.com/HNAP1/Login",
    { HNAP_AUTH: HNAP_AUTH },
    loginFinal,
    cookieHeader,
  );

  if (args.verbose)
    console.log("📥 Final login response:", finalResp.LoginResponse);

  if (finalResp.LoginResponse.LoginResult === "OK") {
    if (args.verbose) console.log("✅ Login successful");
  } else {
    console.error("❌ Login failed: credentials or HMAC mismatch.");
    return;
  }
  if (args.getDownstream) {
    const parsed = await fetchChannelInfo("down", PrivateKey, cookieHeader);
    console.log(JSON.stringify(parsed, null, 2));
  }

  if (args.getUpstream) {
    const parsed = await fetchChannelInfo("up", PrivateKey, cookieHeader);
    console.log(JSON.stringify(parsed, null, 2));
  }

  if (args.getStatus) {
    const parsed = await fetchChannelInfo("status", PrivateKey, cookieHeader);
    console.log(JSON.stringify(parsed, null, 2));
  }
  if (args.getSoftware) {
    const parsed = await fetchChannelInfo("software", PrivateKey, cookieHeader);
    console.log(JSON.stringify(parsed, null, 2));
  }
  if (args.getConnection) {
    const parsed = await fetchChannelInfo(
      "connection",
      PrivateKey,
      cookieHeader,
    );
    console.log(JSON.stringify(parsed, null, 2));
  }
})();
